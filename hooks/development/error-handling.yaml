---
category: development
priority: high
agents: [maker-agent]
description: "Implements comprehensive error handling patterns"
tags: [error-handling, try-catch, validation, logging]
last_updated: "2025-09-07"
mcp_dependencies: []
---

# Error Handling Hook
# Implements comprehensive error handling patterns across all code creation

hook_name: error-handling
version: "1.0"
trigger: "on_function_create"

# CORE ERROR HANDLING ACTIONS
actions:
  add_try_catch:
    description: "Wrap operations in appropriate error handling"
    required: true
    implementation: |
      - Wrap all external API calls
      - Handle file system operations
      - Manage database operations
      - Catch parsing/serialization errors
    
  add_validation:
    description: "Input validation and sanitization"
    required: true
    implementation: |
      - Validate function parameters
      - Check data types and ranges
      - Sanitize user inputs
      - Validate configuration values
    
  add_logging:
    description: "Comprehensive error logging"
    required: true
    implementation: |
      - Log error details with context
      - Include stack traces
      - Add correlation IDs
      - Implement structured logging
    
  define_recovery:
    description: "Error recovery strategies"
    required: false
    implementation: |
      - Implement retry mechanisms
      - Define fallback behaviors
      - Graceful degradation
      - Circuit breaker patterns

# ERROR HANDLING PATTERNS
patterns:
  try_catch_finally:
    description: "Standard try-catch-finally pattern"
    languages: [javascript, typescript, python, java, c#]
    template: |
      try {
        // Main operation
      } catch (error) {
        // Error handling
        logger.error('Operation failed', { error, context });
        throw new CustomError('Operation failed', error);
      } finally {
        // Cleanup
      }
  
  error_boundaries:
    description: "React error boundary pattern"
    languages: [javascript, typescript]
    frameworks: [react]
    template: |
      class ErrorBoundary extends React.Component {
        constructor(props) {
          super(props);
          this.state = { hasError: false };
        }
        
        static getDerivedStateFromError(error) {
          return { hasError: true };
        }
        
        componentDidCatch(error, errorInfo) {
          logger.error('Component error', { error, errorInfo });
        }
        
        render() {
          if (this.state.hasError) {
            return <ErrorFallback />;
          }
          return this.props.children;
        }
      }
  
  circuit_breakers:
    description: "Circuit breaker pattern for external services"
    template: |
      class CircuitBreaker {
        constructor(threshold = 5, timeout = 60000) {
          this.threshold = threshold;
          this.timeout = timeout;
          this.state = 'CLOSED';
          this.failures = 0;
          this.lastFailTime = null;
        }
        
        async call(operation) {
          if (this.state === 'OPEN') {
            if (Date.now() - this.lastFailTime < this.timeout) {
              throw new Error('Circuit breaker is OPEN');
            }
            this.state = 'HALF_OPEN';
          }
          
          try {
            const result = await operation();
            this.onSuccess();
            return result;
          } catch (error) {
            this.onFailure();
            throw error;
          }
        }
      }
  
  graceful_degradation:
    description: "Graceful degradation with fallback"
    template: |
      async function robustOperation() {
        try {
          return await primaryOperation();
        } catch (primaryError) {
          logger.warn('Primary operation failed, trying fallback', { primaryError });
          try {
            return await fallbackOperation();
          } catch (fallbackError) {
            logger.error('Both operations failed', { primaryError, fallbackError });
            return defaultValue();
          }
        }
      }

# VALIDATION STRATEGIES
validation:
  input_validation:
    type_checking:
      javascript: |
        function validateInput(input, schema) {
          if (typeof input !== schema.type) {
            throw new ValidationError(`Expected ${schema.type}, got ${typeof input}`);
          }
        }
      
      python: |
        from typing import TypeVar, get_type_hints
        
        def validate_types(func):
            def wrapper(*args, **kwargs):
                hints = get_type_hints(func)
                # Validate arguments against type hints
                return func(*args, **kwargs)
            return wrapper
      
      go: |
        func ValidateStruct(s interface{}) error {
          v := reflect.ValueOf(s)
          t := reflect.TypeOf(s)
          
          for i := 0; i < v.NumField(); i++ {
            field := v.Field(i)
            fieldType := t.Field(i)
            
            if err := validateField(field, fieldType); err != nil {
              return fmt.Errorf("validation failed for field %s: %w", fieldType.Name, err)
            }
          }
          return nil
        }
    
    range_checking:
      numeric_ranges: |
        function validateRange(value, min, max, fieldName) {
          if (value < min || value > max) {
            throw new RangeError(`${fieldName} must be between ${min} and ${max}, got ${value}`);
          }
        }
      
      string_length: |
        function validateStringLength(str, minLen, maxLen, fieldName) {
          if (str.length < minLen || str.length > maxLen) {
            throw new ValidationError(`${fieldName} length must be between ${minLen} and ${maxLen}`);
          }
        }
    
    format_validation:
      email: |
        function validateEmail(email) {
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(email)) {
            throw new ValidationError('Invalid email format');
          }
        }
      
      url: |
        function validateURL(url) {
          try {
            new URL(url);
          } catch {
            throw new ValidationError('Invalid URL format');
          }
        }

# LOGGING STRATEGIES
logging:
  structured_logging:
    format: "JSON"
    fields:
      - timestamp
      - level
      - message
      - error
      - context
      - correlation_id
      - user_id
      - request_id
    
    template: |
      {
        "timestamp": "2025-09-07T10:30:00.000Z",
        "level": "ERROR",
        "message": "Database operation failed",
        "error": {
          "name": "DatabaseError",
          "message": "Connection timeout",
          "stack": "..."
        },
        "context": {
          "operation": "user_fetch",
          "user_id": "12345",
          "query": "SELECT * FROM users WHERE id = ?"
        },
        "correlation_id": "req-789-xyz",
        "service": "user-service"
      }
  
  error_levels:
    FATAL:
      description: "System unusable, immediate attention required"
      examples: ["Database completely unavailable", "Critical security breach"]
      action: "Page on-call engineer"
    
    ERROR:
      description: "Error conditions that need attention"
      examples: ["API call failures", "File system errors"]
      action: "Log and alert"
    
    WARN:
      description: "Warning conditions that should be monitored"
      examples: ["Deprecated API usage", "Performance degradation"]
      action: "Log for analysis"
    
    INFO:
      description: "Informational messages"
      examples: ["Request processed", "Operation completed"]
      action: "Standard logging"
  
  context_enrichment:
    user_context: ["user_id", "session_id", "role"]
    request_context: ["request_id", "method", "path", "ip"]
    business_context: ["tenant_id", "operation_type", "feature_flag"]
    technical_context: ["service_name", "version", "environment"]

# ERROR RECOVERY MECHANISMS
recovery:
  retry_strategies:
    exponential_backoff:
      initial_delay: 1000  # ms
      max_delay: 30000     # ms
      multiplier: 2
      jitter: true
      max_attempts: 5
      
      implementation: |
        async function retryWithBackoff(operation, options = {}) {
          const { maxAttempts = 5, initialDelay = 1000, multiplier = 2 } = options;
          
          for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
              return await operation();
            } catch (error) {
              if (attempt === maxAttempts) throw error;
              
              const delay = Math.min(
                initialDelay * Math.pow(multiplier, attempt - 1),
                30000
              );
              
              await sleep(delay + Math.random() * 1000); // Add jitter
            }
          }
        }
    
    linear_backoff:
      delay: 2000  # ms
      max_attempts: 3
      
      implementation: |
        async function retryLinear(operation, maxAttempts = 3, delay = 2000) {
          for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
              return await operation();
            } catch (error) {
              if (attempt === maxAttempts) throw error;
              await sleep(delay);
            }
          }
        }
  
  fallback_mechanisms:
    cache_fallback: |
      async function withCacheFallback(operation, cacheKey) {
        try {
          const result = await operation();
          cache.set(cacheKey, result);
          return result;
        } catch (error) {
          const cached = cache.get(cacheKey);
          if (cached) {
            logger.warn('Using cached fallback', { cacheKey, error });
            return cached;
          }
          throw error;
        }
      }
    
    default_value_fallback: |
      function withDefaultFallback(operation, defaultValue) {
        try {
          return operation();
        } catch (error) {
          logger.warn('Using default fallback', { defaultValue, error });
          return defaultValue;
        }
      }
    
    alternative_service: |
      async function withServiceFallback(primaryService, fallbackService, request) {
        try {
          return await primaryService.call(request);
        } catch (primaryError) {
          logger.warn('Primary service failed, trying fallback', { primaryError });
          return await fallbackService.call(request);
        }
      }

# ERROR TYPES AND CLASSIFICATIONS
error_types:
  system_errors:
    - OutOfMemoryError
    - FileSystemError
    - NetworkError
    - DatabaseConnectionError
    
    handling: |
      - Log with high severity
      - Implement circuit breakers
      - Alert operations team
      - Graceful degradation
  
  user_errors:
    - ValidationError
    - AuthenticationError
    - AuthorizationError
    - RateLimitError
    
    handling: |
      - Return user-friendly messages
      - Log for security monitoring
      - Implement rate limiting
      - Provide corrective guidance
  
  business_errors:
    - InsufficientFundsError
    - ProductOutOfStockError
    - BusinessRuleViolationError
    
    handling: |
      - Return specific error codes
      - Log for business intelligence
      - Provide alternative actions
      - Maintain audit trails
  
  integration_errors:
    - APITimeoutError
    - APIRateLimitError
    - APIVersionMismatchError
    - ServiceUnavailableError
    
    handling: |
      - Implement retry logic
      - Use circuit breakers
      - Cache when possible
      - Monitor SLA compliance

# TESTING ERROR SCENARIOS
error_testing:
  unit_tests:
    - test_invalid_input_handling
    - test_null_reference_handling
    - test_boundary_conditions
    - test_exception_propagation
  
  integration_tests:
    - test_external_service_failures
    - test_database_connection_failures
    - test_network_timeouts
    - test_partial_failures
  
  chaos_testing:
    - random_service_failures
    - network_partitions
    - resource_exhaustion
    - dependency_failures
  
  error_injection:
    techniques:
      - fault_injection_libraries
      - service_mesh_failures
      - infrastructure_chaos
      - application_level_failures

# MONITORING AND ALERTING
monitoring:
  error_metrics:
    - error_rate
    - error_types_distribution
    - recovery_success_rate
    - mean_time_to_recovery
  
  alerting_rules:
    critical:
      - error_rate > 5%
      - no_recovery_in_5_minutes
      - critical_service_down
    
    warning:
      - error_rate > 1%
      - degraded_performance
      - high_retry_rate
  
  dashboards:
    - error_rate_over_time
    - error_types_breakdown
    - service_health_overview
    - recovery_patterns