---
category: mcp-integration
priority: high
agents: [maker-agent, reader-agent, debug-agent, security-agent, test-agent]
description: "Semantic code intelligence through Serena MCP"
tags: [serena, mcp, symbols, references, refactoring]
last_updated: "2025-09-07"
mcp_dependencies: [serena]
---

# Serena Integration Hook
# Semantic code intelligence and symbol manipulation through Serena MCP

hook_name: serena-integration
version: "2.0"
trigger: "on_symbol_operation"

# CORE SERENA ACTIONS
actions:
  resolve_symbols:
    description: "Get symbol definitions and metadata"
    required: true
    mcp_server: "serena"
    implementation: |
      - Use getSymbolDefinition for precise locations
      - Retrieve symbol metadata and context
      - Get type information and signatures
      - Analyze symbol scope and visibility
      - Cache results for performance
    
  find_references:
    description: "Locate all symbol usage points"
    required: true
    mcp_server: "serena"
    implementation: |
      - Use getSymbolReferences for comprehensive search
      - Include read and write references
      - Filter by scope and context if needed
      - Track reference relationships
      - Support cross-file reference analysis
    
  safe_refactoring:
    description: "Perform symbol-aware code modifications"
    required: true
    mcp_server: "serena"
    implementation: |
      - Use renameSymbol for safe renaming
      - Validate all references before changes
      - Apply changes atomically across files
      - Preserve semantic correctness
      - Generate comprehensive edit lists
    
  analyze_structure:
    description: "Understand code structure and relationships"
    required: false
    mcp_server: "serena"
    implementation: |
      - Use getWorkspaceSymbols for project overview
      - Build symbol hierarchy and relationships
      - Analyze inheritance and composition
      - Map module dependencies
      - Generate architectural insights

# SERENA MCP OPERATIONS
operations:
  symbol_definition:
    operation: "getSymbolDefinition"
    parameters:
      - symbol_name: "Symbol identifier"
      - location: "Source location context"
      - include_metadata: "Additional symbol information"
    
    returns:
      - definition_location: "Where symbol is defined"
      - symbol_type: "Symbol category and type"
      - signature: "Function/method signature"
      - documentation: "Associated documentation"
      - scope_context: "Containing scope information"
    
    use_cases:
      navigation:
        description: "Go to definition functionality"
        implementation: |
          const definition = await serena.getSymbolDefinition(symbolName, currentLocation);
          if (definition) {
            return {
              file: definition.location.file,
              line: definition.location.line,
              column: definition.location.column,
              preview: definition.context
            };
          }
      
      documentation:
        description: "Extract symbol documentation"
        implementation: |
          const definition = await serena.getSymbolDefinition(symbolName, currentLocation, {
            include_metadata: true
          });
          return definition.documentation || definition.comments || null;
      
      type_analysis:
        description: "Analyze symbol types and signatures"
        implementation: |
          const definition = await serena.getSymbolDefinition(symbolName, currentLocation);
          return {
            type: definition.type,
            signature: definition.signature,
            parameters: definition.parameters,
            return_type: definition.return_type
          };
  
  symbol_references:
    operation: "getSymbolReferences"
    parameters:
      - symbol_name: "Symbol to search for"
      - location: "Symbol definition or usage location"
      - include_declaration: "Include definition location"
      - scope_filter: "Limit search scope"
    
    returns:
      - references: "List of all reference locations"
      - reference_types: "Read/write/call classifications"
      - context: "Surrounding code context"
      - usage_patterns: "How symbol is being used"
    
    use_cases:
      find_usages:
        description: "Find all places where symbol is used"
        implementation: |
          const references = await serena.getSymbolReferences(symbolName, location, {
            include_declaration: true,
            scope_filter: 'project'
          });
          
          return references.map(ref => ({
            file: ref.location.file,
            line: ref.location.line,
            column: ref.location.column,
            context: ref.context,
            type: ref.reference_type  // 'read', 'write', 'call'
          }));
      
      impact_analysis:
        description: "Analyze impact of symbol changes"
        implementation: |
          const references = await serena.getSymbolReferences(symbolName, location);
          
          const impact = {
            total_references: references.length,
            files_affected: [...new Set(references.map(r => r.location.file))].length,
            reference_types: references.reduce((acc, ref) => {
              acc[ref.reference_type] = (acc[ref.reference_type] || 0) + 1;
              return acc;
            }, {}),
            high_risk_areas: references.filter(ref => ref.context.includes('public') || ref.context.includes('export'))
          };
          
          return impact;
      
      dependency_tracking:
        description: "Track symbol dependencies"
        implementation: |
          const references = await serena.getSymbolReferences(symbolName, location);
          
          const dependencies = references.map(ref => ({
            dependent_symbol: extractSymbolFromContext(ref.context),
            dependency_type: ref.reference_type,
            location: ref.location,
            strength: calculateDependencyStrength(ref)
          }));
          
          return dependencies;
  
  workspace_symbols:
    operation: "getWorkspaceSymbols"
    parameters:
      - query: "Symbol search pattern (optional)"
      - symbol_types: "Filter by symbol types"
      - scope: "Search scope (project, directory, file)"
    
    returns:
      - symbols: "Matching symbols with metadata"
      - hierarchies: "Symbol containment relationships"
      - modules: "Module and namespace organization"
    
    use_cases:
      symbol_search:
        description: "Search for symbols across project"
        implementation: |
          const symbols = await serena.getWorkspaceSymbols(query, {
            symbol_types: ['function', 'class', 'interface'],
            scope: 'project'
          });
          
          return symbols.map(symbol => ({
            name: symbol.name,
            type: symbol.type,
            location: symbol.location,
            container: symbol.container,
            signature: symbol.signature,
            relevance: calculateRelevance(symbol, query)
          })).sort((a, b) => b.relevance - a.relevance);
      
      project_overview:
        description: "Generate project structure overview"
        implementation: |
          const symbols = await serena.getWorkspaceSymbols(null, {
            symbol_types: ['class', 'interface', 'module', 'namespace'],
            scope: 'project'
          });
          
          const structure = buildHierarchy(symbols);
          return {
            total_symbols: symbols.length,
            by_type: groupByType(symbols),
            hierarchy: structure,
            complexity_metrics: calculateComplexity(symbols)
          };
      
      code_navigation:
        description: "Generate navigation aids"
        implementation: |
          const symbols = await serena.getWorkspaceSymbols(null, {
            scope: 'project'
          });
          
          return {
            outline: buildFileOutlines(symbols),
            breadcrumbs: generateBreadcrumbs(symbols),
            cross_references: buildCrossReferences(symbols),
            hotspots: identifyComplexAreas(symbols)
          };
  
  symbol_rename:
    operation: "renameSymbol"
    parameters:
      - symbol_name: "Current symbol name"
      - new_name: "Desired new name"
      - location: "Symbol location context"
      - preview_mode: "Generate preview without applying"
    
    returns:
      - workspace_edit: "Complete set of file changes"
      - affected_files: "List of files to be modified"
      - validation_results: "Pre-change validation"
      - conflict_detection: "Naming conflicts and issues"
    
    use_cases:
      safe_renaming:
        description: "Rename symbols safely across codebase"
        implementation: |
          // Phase 1: Validate rename operation
          const validation = await serena.renameSymbol(oldName, newName, location, {
            preview_mode: true
          });
          
          if (validation.conflicts.length > 0) {
            throw new Error(`Rename conflicts: ${validation.conflicts.join(', ')}`);
          }
          
          // Phase 2: Apply rename
          const edit = await serena.renameSymbol(oldName, newName, location, {
            preview_mode: false
          });
          
          // Phase 3: Apply changes atomically
          return applyWorkspaceEdit(edit);
      
      bulk_refactoring:
        description: "Rename multiple symbols consistently"
        implementation: |
          const renames = [];
          
          for (const { oldName, newName, location } of renameOperations) {
            const edit = await serena.renameSymbol(oldName, newName, location, {
              preview_mode: true
            });
            renames.push({ oldName, newName, edit });
          }
          
          // Validate all renames for conflicts
          const conflicts = detectCrossRenameConflicts(renames);
          if (conflicts.length > 0) {
            throw new Error(`Cross-rename conflicts detected: ${conflicts}`);
          }
          
          // Apply all renames atomically
          return applyBulkRenames(renames);

# AGENT-SPECIFIC SERENA USAGE PATTERNS
agent_patterns:
  maker-agent:
    symbol_aware_generation:
      description: "Generate code with full symbol awareness"
      workflow: |
        1. Analyze existing code structure with getWorkspaceSymbols
        2. Identify naming patterns and conventions
        3. Check for naming conflicts with getSymbolReferences
        4. Generate code following established patterns
        5. Validate generated symbols don't conflict
      
      implementation: |
        async function generateSymbolAwareCode(codeSpec) {
          // Analyze existing patterns
          const existingSymbols = await serena.getWorkspaceSymbols(null, {
            scope: codeSpec.scope
          });
          
          const patterns = analyzeNamingPatterns(existingSymbols);
          const conventions = extractConventions(existingSymbols);
          
          // Generate code following patterns
          const generatedCode = await generateCode(codeSpec, patterns, conventions);
          
          // Validate no conflicts
          const conflicts = await validateNewSymbols(generatedCode.symbols);
          
          if (conflicts.length > 0) {
            return resolveSymbolConflicts(generatedCode, conflicts);
          }
          
          return generatedCode;
        }
    
    refactoring_coordination:
      description: "Coordinate complex refactoring operations"
      capabilities:
        - Multi-file symbol renaming
        - Signature changes with call site updates
        - Symbol extraction and inlining
        - Dependency restructuring
      
      workflow: |
        1. Analyze refactoring scope with getSymbolReferences
        2. Plan changes with impact analysis
        3. Generate atomic change sets with renameSymbol
        4. Validate changes maintain semantic correctness
        5. Apply changes using workspace edits
  
  reader-agent:
    code_structure_analysis:
      description: "Deep structural analysis of codebases"
      capabilities:
        - Symbol hierarchy mapping
        - Dependency graph construction
        - Architecture pattern detection
        - Code complexity analysis
      
      implementation: |
        async function analyzeCodeStructure(projectPath) {
          // Get all symbols
          const symbols = await serena.getWorkspaceSymbols(null, {
            scope: 'project'
          });
          
          // Build dependency graph
          const dependencies = await buildDependencyGraph(symbols);
          
          // Analyze patterns
          const patterns = detectArchitecturalPatterns(symbols, dependencies);
          
          // Calculate metrics
          const metrics = calculateStructuralMetrics(symbols, dependencies);
          
          return {
            symbol_count: symbols.length,
            dependency_graph: dependencies,
            architectural_patterns: patterns,
            complexity_metrics: metrics,
            hotspots: identifyComplexityHotspots(metrics)
          };
        }
    
    symbol_search_optimization:
      description: "Optimized symbol search and discovery"
      features:
        - Fuzzy symbol matching
        - Context-aware search ranking
        - Symbol usage frequency analysis
        - Cross-reference navigation
  
  debug-agent:
    call_graph_analysis:
      description: "Analyze execution paths and call relationships"
      use_cases:
        - Trace error propagation paths
        - Identify potential deadlock cycles
        - Analyze performance bottlenecks
        - Map data flow through system
      
      implementation: |
        async function analyzeCallGraph(entryPoint) {
          const entrySymbol = await serena.getSymbolDefinition(entryPoint.name, entryPoint.location);
          
          const callGraph = {
            nodes: new Map(),
            edges: new Set(),
            paths: []
          };
          
          await buildCallGraphRecursive(entrySymbol, callGraph, new Set());
          
          return {
            graph: callGraph,
            cycles: detectCycles(callGraph),
            critical_paths: findCriticalPaths(callGraph),
            complexity_metrics: calculateCallGraphComplexity(callGraph)
          };
        }
    
    error_context_analysis:
      description: "Analyze code context around errors"
      capabilities:
        - Symbol state analysis at error points
        - Call chain reconstruction
        - Variable scope and lifetime analysis
        - Reference relationship mapping
  
  security-agent:
    data_flow_analysis:
      description: "Track data flow for security analysis"
      security_patterns:
        - Input validation tracking
        - Sensitive data flow analysis
        - Permission and access control analysis
        - Injection vulnerability detection
      
      implementation: |
        async function analyzeDataFlow(sourceSymbol, sinkSymbols) {
          const sources = await serena.getSymbolReferences(sourceSymbol.name, sourceSymbol.location);
          
          const flows = [];
          
          for (const source of sources) {
            for (const sink of sinkSymbols) {
              const path = await findDataFlowPath(source, sink);
              if (path) {
                flows.push({
                  source: source,
                  sink: sink,
                  path: path,
                  risk_level: assessRiskLevel(path),
                  vulnerabilities: detectVulnerabilities(path)
                });
              }
            }
          }
          
          return flows;
        }
    
    access_control_analysis:
      description: "Analyze access patterns and permissions"
      focus_areas:
        - Public API surface analysis
        - Private member access patterns
        - Cross-module visibility
        - Security boundary enforcement
  
  test-agent:
    test_coverage_analysis:
      description: "Analyze test coverage at symbol level"
      metrics:
        - Symbol-level coverage
        - Path coverage through symbols
        - Integration test coverage
        - Missing test scenarios
      
      implementation: |
        async function analyzeSymbolCoverage(testResults) {
          const allSymbols = await serena.getWorkspaceSymbols(null, {
            scope: 'project',
            symbol_types: ['function', 'method', 'class']
          });
          
          const coverage = {
            covered_symbols: new Set(),
            uncovered_symbols: new Set(),
            partially_covered: new Set(),
            coverage_paths: new Map()
          };
          
          for (const symbol of allSymbols) {
            const symbolCoverage = analyzeSingleSymbolCoverage(symbol, testResults);
            categorizeSymbolCoverage(symbol, symbolCoverage, coverage);
          }
          
          return {
            total_symbols: allSymbols.length,
            coverage_percentage: (coverage.covered_symbols.size / allSymbols.length) * 100,
            detailed_coverage: coverage,
            recommendations: generateCoverageRecommendations(coverage)
          };
        }
    
    test_impact_analysis:
      description: "Determine which tests are affected by code changes"
      approach:
        - Symbol change detection
        - Test dependency mapping
        - Regression test selection
        - Test execution optimization

# PERFORMANCE OPTIMIZATION
performance:
  caching_strategies:
    symbol_cache:
      description: "Cache symbol definitions and metadata"
      cache_levels:
        - In-memory symbol cache (5-minute TTL)
        - Persistent symbol index (updated on file changes)
        - Cross-session symbol knowledge base
      
      invalidation_triggers:
        - File modifications
        - Symbol renames
        - Project structure changes
        - Dependency updates
    
    reference_cache:
      description: "Cache reference lookups"
      strategies:
        - Incremental reference updates
        - Batched reference queries
        - Selective cache invalidation
        - Reference relationship graphs
  
  batch_operations:
    bulk_symbol_analysis:
      description: "Analyze multiple symbols efficiently"
      optimization: |
        async function batchSymbolAnalysis(symbols) {
          // Group symbols by file for efficient processing
          const symbolsByFile = groupBy(symbols, 'file');
          
          const results = [];
          
          for (const [file, fileSymbols] of symbolsByFile) {
            // Process all symbols in a file together
            const batchResult = await serena.getMultipleSymbolDefinitions(fileSymbols, {
              include_metadata: true,
              include_references: true
            });
            results.push(...batchResult);
          }
          
          return results;
        }
    
    parallel_processing:
      description: "Parallel symbol operations where safe"
      guidelines:
        - Read operations can be parallelized
        - Write operations need coordination
        - Cache consistency considerations
        - Resource usage monitoring

# ERROR HANDLING AND FALLBACKS
error_handling:
  serena_unavailable:
    fallback_strategy: "text_based_analysis"
    implementation: |
      async function fallbackSymbolAnalysis(symbolName, location) {
        console.warn('Serena MCP unavailable, falling back to text-based analysis');
        
        // Use grep/search for basic symbol finding
        const textMatches = await Grep({
          pattern: `\\b${symbolName}\\b`,
          path: location.file,
          output_mode: "content",
          "-n": true
        });
        
        return {
          type: 'text_match',
          matches: textMatches,
          confidence: 'low',
          source: 'fallback'
        };
      }
    
    limitations:
      - No semantic understanding
      - False positives in matches
      - No cross-reference accuracy
      - Limited refactoring safety
  
  partial_failures:
    handling_strategy: "best_effort_completion"
    approach:
      - Continue with successful operations
      - Log partial failures clearly
      - Provide degraded functionality
      - Report incomplete analysis

# INTEGRATION QUALITY ASSURANCE
quality_assurance:
  validation_checks:
    symbol_consistency:
      - Verify symbol definitions match references
      - Check cross-file symbol integrity
      - Validate symbol hierarchy consistency
      - Ensure reference completeness
    
    operation_validation:
      - Pre-operation safety checks
      - Post-operation verification
      - Rollback capability validation
      - Change impact assessment
  
  monitoring:
    serena_health:
      - Operation success rates
      - Response time monitoring
      - Error pattern tracking
      - Performance degradation detection
    
    usage_analytics:
      - Most frequently accessed symbols
      - Common operation patterns
      - Performance bottlenecks
      - User workflow optimization opportunities